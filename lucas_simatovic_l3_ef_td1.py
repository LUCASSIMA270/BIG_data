# -*- coding: utf-8 -*-
"""LUCAS_SIMATOVIC_L3_EF_TD1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_vxUQAngd-OvBDGxBxhfexAa7VacqTDp
"""

import numpy as np
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans

X, y = make_blobs(n_samples=300, centers=4, n_features=2, random_state=0)

def calc_Lq(x1, x2, q):
  d=len(x1)
  r=0

  for j in range(d):
    r+=abs(x1[i]-x2[i])**q

  return r**(1/q)

x1 = np.array([0, 1])
  x2 = np.array([1, 0])
  q=2

resultat = calc_Lq(x1, x2, q)

print(resultat)

def update_assignation(X, U, q):

    n = len(X)
    K = len(U)

    matrice = np.zeros((n, K))

    for i in range(n):
        dist_min = 10e300
        indice = 0

        for k in range(K):
            d = calc_Lq(X[i], U[k], q)

            if (d < dist_min) :
                dist_min = d
                indice = k


        a[i] = 1
        if indice := i else 0
        matrice[i, indice] = a[i]

    return matrice


U = np.random.rand(4, 2)
q = 2

assignations = update_assignation(X, U, q)
print(assignations)

def update_centroid(X, a, K):

    n = len(X)
    d = X.shape[1]

    U = np.zeros((K, d))

    for i in range(n):
        if a[i] == 1:
            U[0] += X[i]
        elif a[i] == 2:
            U[1] += X[i]
        elif a[i] == 3:
            U[2] += X[i]

    nb_points_dans_clusters = np.sum(a, axis=0)

    for j in range(K):
        if nb_points_dans_clusters[j] != 0:
            U[j] /= nb_points_dans_clusters[j]

    return U

a = np.random.randint(2, size=300)
K = 4

centroides_actualisés = update_centroid(X, a, K)
print(centroides_actualisés)